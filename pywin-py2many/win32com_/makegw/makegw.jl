#= Utility functions for writing out gateway C++ files

  This module will generate a C++/Python binding for a specific COM
  interface.

  At this stage, no command line interface exists.  You must start Python, 
  import this module,  change to the directory where the generated code should
  be written, and run the public function.

  This module is capable of generating both 'Interfaces' (ie, Python
  client side support for the interface) and 'Gateways' (ie, Python
  server side support for the interface).  Many COM interfaces are useful
  both as Client and Server.  Other interfaces, however, really only make
  sense to implement one side or the other.  For example, it would be pointless
  for Python to implement Server side for 'IRunningObjectTable', unless we were
  implementing core COM for an operating system in Python (hey - now there's an idea!)

  Most COM interface code is totally boiler-plate - it consists of
  converting arguments, dispatching the call to Python, and processing
  any result values.

  This module automates the generation of such code.  It has the ability to
  parse a .H file generated by the MIDL tool (ie, almost all COM .h files)
  and build almost totally complete C++ code.

  The module understands some of the well known data types, and how to
  convert them.  There are only a couple of places where hand-editing is
  necessary, as detailed below:

  unsupported types -- If a type is not known, the generator will
  pretty much ignore it, but write a comment to the generated code.  You
  may want to add custom support for this type.  In some cases, C++ compile errors
  will result.  These are intentional - generating code to remove these errors would
  imply a false sense of security that the generator has done the right thing.

  other return policies -- By default, Python never sees the return SCODE from
  a COM function.  The interface usually returns None if OK, else a COM exception
  if "FAILED(scode)" is TRUE.  You may need to change this if:
  * EXCEPINFO is passed to the COM function.  This is not detected and handled
  * For some reason Python should always see the result SCODE, even if it
    did fail or succeed.  For example, some functions return a BOOLEAN result
    in the SCODE, meaning Python should always see it.
  * FAILED(scode) for the interface still has valid data to return (by default,
    the code generated does not process the return values, and raise an exception
    to Python/COM

 =#
import win32com_.makegw.makegwenum

include("makegwparse.jl")
function make_framework_support(
    header_file_name,
    interface_name,
    bMakeInterface = 1,
    bMakeGateway = 1,
)
    #= Generate C++ code for a Python Interface and Gateway

        header_file_name -- The full path to the .H file which defines the interface.
        interface_name -- The name of the interface to search for, and to generate.
        bMakeInterface = 1 -- Should interface (ie, client) support be generated.
        bMakeGatewayInterface = 1 -- Should gateway (ie, server) support be generated.

        This method will write a .cpp and .h file into the current directory,
        (using the name of the interface to build the file name.

         =#
    fin = readline(header_file_name)
    try
        interface = makegwparse.parse_interface_info(interface_name, fin)
    finally
        close(fin)
    end
    if bMakeInterface && bMakeGateway
        desc = "Interface and Gateway"
    elseif bMakeInterface && !(bMakeGateway)
        desc = "Interface"
    else
        desc = "Gateway"
    end
    if interface.name[begin:5] == "IEnum"
        ifc_cpp_writer = win32com_.makegw.makegwenum._write_enumifc_cpp
        gw_cpp_writer = win32com_.makegw.makegwenum._write_enumgw_cpp
    else
        ifc_cpp_writer = _write_ifc_cpp
        gw_cpp_writer = _write_gw_cpp
    end
    fout = readline("Py%s.cpp" % interface.name)
    try
        write(
            fout,
            "// This file implements the %s %s for Python.\n// Generated by makegw.py\n\n#include \"shell_pch.h\"\n" %
            (interface.name, desc),
        )
        write(
            fout,
            "#include \"Py%s.h\"\n\n// @doc - This file contains autoduck documentation\n" %
            interface.name,
        )
        if bMakeInterface
            ifc_cpp_writer(fout, interface)
        end
        if bMakeGateway
            gw_cpp_writer(fout, interface)
        end
    finally
        close(fout)
    end
    fout = readline("Py%s.h" % interface.name)
    try
        write(
            fout,
            "// This file declares the %s %s for Python.\n// Generated by makegw.py\n" %
            (interface.name, desc),
        )
        if bMakeInterface
            _write_ifc_h(fout, interface)
        end
        if bMakeGateway
            _write_gw_h(fout, interface)
        end
    finally
        close(fout)
    end
end

function _write_ifc_h(f, interface)
    write(
        f,
        "// ---------------------------------------------------\n//\n// Interface Declaration\n\nclass Py%s : public Py%s\n{\npublic:\n\tMAKE_PYCOM_CTOR(Py%s);\n\tstatic %s *GetI(PyObject *self);\n\tstatic PyComTypeObject type;\n\n\t// The Python methods\n" %
        (interface.name, interface.base, interface.name, interface.name),
    )
    for method in interface.methods
        write(f, "\tstatic PyObject *%s(PyObject *self, PyObject *args);\n" % method.name)
    end
    write(
        f,
        "\nprotected:\n\tPy%s(IUnknown *pdisp);\n\t~Py%s();\n};\n" %
        (interface.name, interface.name),
    )
end

function _write_ifc_cpp(f, interface)
    name = interface.name
    write(
        f,
        "// ---------------------------------------------------\n//\n// Interface Implementation\n\nPy%(name)s::Py%(name)s(IUnknown *pdisp):\n\tPy%(base)s(pdisp)\n{\n\tob_type = &type;\n}\n\nPy%(name)s::~Py%(name)s()\n{\n}\n\n/* static */ %(name)s *Py%(name)s::GetI(PyObject *self)\n{\n\treturn (%(name)s *)Py%(base)s::GetI(self);\n}\n\n" %
        interface.__dict__,
    )
    ptr =
    # Unsupported use of re.sub with less than 3 arguments
        sub()("[a-z]", "", interface.name)
    strdict = Dict("interfacename" => interface.name, "ptr" => ptr)
    for method in interface.methods
        strdict["method"] = method.name
        write(
            f,
            "// @pymethod |Py%(interfacename)s|%(method)s|Description of %(method)s.\nPyObject *Py%(interfacename)s::%(method)s(PyObject *self, PyObject *args)\n{\n\t%(interfacename)s *p%(ptr)s = GetI(self);\n\tif ( p%(ptr)s == NULL )\n\t\treturn NULL;\n" %
            strdict,
        )
        argsParseTuple = ""
        argsCOM = ""
        formatChars = ""
        codePost = ""
        codePobjects = ""
        codeCobjects = ""
        cleanup = ""
        cleanup_gil = ""
        needConversion = 0
        for arg in method.args
            try
                argCvt = makegwparse.make_arg_converter(arg)
                if HasAttribute(arg, "in")
                    val = GetFormatChar(argCvt)
                    if val
                        write(f, ("\t" + GetAutoduckString(argCvt)) * "\n")
                        formatChars = formatChars + val
                        argsParseTuple = argsParseTuple * ", " + GetParseTupleArg(argCvt)
                        codePobjects =
                            codePobjects + DeclareParseArgTupleInputConverter(argCvt)
                        codePost = codePost + GetParsePostCode(argCvt)
                        needConversion = needConversion || NeedUSES_CONVERSION(argCvt)
                        cleanup = cleanup + GetInterfaceArgCleanup(argCvt)
                        cleanup_gil = cleanup_gil + GetInterfaceArgCleanupGIL(argCvt)
                    end
                end
                comArgName, comArgDeclString = GetInterfaceCppObjectInfo(argCvt)
                if comArgDeclString
                    codeCobjects = codeCobjects * ("\t%s;\n" % comArgDeclString)
                end
                argsCOM = argsCOM * ", " + comArgName
            catch exn
                let why = exn
                    if why isa makegwparse.error_not_supported
                        write(
                            f,
                            "// *** The input argument %s of type \"%s\" was not processed ***\n//     Please check the conversion function is appropriate and exists!\n" %
                            (arg.name, arg.raw_type),
                        )
                        write(
                            f,
                            "\t%s %s;\n\tPyObject *ob%s;\n" %
                            (arg.type, arg.name, arg.name),
                        )
                        write(
                            f,
                            "\t// @pyparm <o Py%s>|%s||Description for %s\n" %
                            (arg.type, arg.name, arg.name),
                        )
                        codePost =
                            codePost + (
                                "\tif (bPythonIsHappy && !PyObject_As%s( ob%s, &%s )) bPythonIsHappy = FALSE;\n" %
                                (arg.type, arg.name, arg.name)
                            )
                        formatChars = formatChars * "O"
                        argsParseTuple = argsParseTuple * (", &ob%s" % arg.name)
                        argsCOM = argsCOM * ", " + arg.name
                        cleanup =
                            cleanup + ("\tPyObject_Free%s(%s);\n" % (arg.type, arg.name))
                    end
                end
            end
        end
        if needConversion != 0
            write(f, "\tUSES_CONVERSION;\n")
        end
        write(f, codePobjects)
        write(f, codeCobjects)
        write(
            f,
            "\tif ( !PyArg_ParseTuple(args, \"%s:%s\"%s) )\n\t\treturn NULL;\n" %
            (formatChars, method.name, argsParseTuple),
        )
        if codePost
            write(f, "\tBOOL bPythonIsHappy = TRUE;\n")
            write(f, codePost)
            write(f, "\tif (!bPythonIsHappy) return NULL;\n")
        end
        strdict["argsCOM"] = argsCOM[2:end]
        strdict["cleanup"] = cleanup
        strdict["cleanup_gil"] = cleanup_gil
        write(
            f,
            "\tHRESULT hr;\n\tPY_INTERFACE_PRECALL;\n\thr = p%(ptr)s->%(method)s(%(argsCOM)s );\n%(cleanup)s\n\tPY_INTERFACE_POSTCALL;\n%(cleanup_gil)s\n\tif ( FAILED(hr) )\n\t\treturn PyCom_BuildPyException(hr, p%(ptr)s, IID_%(interfacename)s );\n" %
            strdict,
        )
        codePre = ""
        codePost = ""
        formatChars = ""
        codeVarsPass = ""
        codeDecl = ""
        for arg in method.args
            if !HasAttribute(arg, "out")
                continue
            end
            try
                argCvt = makegwparse.make_arg_converter(arg)
                formatChar = GetFormatChar(argCvt)
                if formatChar
                    formatChars = formatChars + formatChar
                    codePre = codePre + GetBuildForInterfacePreCode(argCvt)
                    codePost = codePost + GetBuildForInterfacePostCode(argCvt)
                    codeVarsPass = codeVarsPass * ", " + GetBuildValueArg(argCvt)
                    codeDecl = codeDecl + DeclareParseArgTupleInputConverter(argCvt)
                end
            catch exn
                let why = exn
                    if why isa makegwparse.error_not_supported
                        write(
                            f,
                            "// *** The output argument %s of type \"%s\" was not processed ***\n//     %s\n" %
                            (arg.name, arg.raw_type, why),
                        )
                        continue
                    end
                end
            end
        end
        if formatChars
            write(
                f,
                "%s\n%s\tPyObject *pyretval = Py_BuildValue(\"%s\"%s);\n%s\treturn pyretval;" %
                (codeDecl, codePre, formatChars, codeVarsPass, codePost),
            )
        else
            write(f, "\tPy_INCREF(Py_None);\n\treturn Py_None;\n")
        end
        write(f, "\n}\n\n")
    end
    write(f, "// @object Py%s|Description of the interface\n" % name)
    write(f, "static struct PyMethodDef Py%s_methods[] =\n{\n" % name)
    for method in interface.methods
        write(
            f,
            "\t{ \"%s\", Py%s::%s, 1 }, // @pymeth %s|Description of %s\n" %
            (method.name, interface.name, method.name, method.name, method.name),
        )
    end
    interfacebase = interface.base
    write(
        f,
        "\t{ NULL }\n};\n\nPyComTypeObject Py%(name)s::type(\"Py%(name)s\",\n\t\t&Py%(interfacebase)s::type,\n\t\tsizeof(Py%(name)s),\n\t\tPy%(name)s_methods,\n\t\tGET_PYCOM_CTOR(Py%(name)s));\n" %
        locals(),
    )
end

function _write_gw_h(f, interface)
    if interface.name[1] == "I"
        gname = "PyG" + interface.name[2:end]
    else
        gname = "PyG" + interface.name
    end
    name = interface.name
    if interface.base == "IUnknown" || interface.base == "IDispatch"
        base_name = "PyGatewayBase"
    elseif interface.base[1] == "I"
        base_name = "PyG" + interface.base[2:end]
    else
        base_name = "PyG" + interface.base
    end
    write(
        f,
        "// ---------------------------------------------------\n//\n// Gateway Declaration\n\nclass %s : public %s, public %s\n{\nprotected:\n\t%s(PyObject *instance) : %s(instance) { ; }\n\tPYGATEWAY_MAKE_SUPPORT2(%s, %s, IID_%s, %s)\n\n" %
        (gname, base_name, name, gname, base_name, gname, name, name, base_name),
    )
    if interface.base != "IUnknown"
        write(
            f,
            "\t// %s\n\t// *** Manually add %s method decls here\n\n" %
            (interface.base, interface.base),
        )
    else
        write(f, "\n\n")
    end
    write(f, "\t// %s\n" % name)
    for method in interface.methods
        write(f, "\tSTDMETHOD(%s)(\n" % method.name)
        if method.args
            for arg in method.args[begin:-1]
                write(f, "\t\t%s,\n" % GetRawDeclaration(arg))
            end
            arg = method.args[end]
            write(f, "\t\t%s);\n\n" % GetRawDeclaration(arg))
        else
            write(f, "\t\tvoid);\n\n")
        end
    end
    write(f, "};\n")
    close(f)
end

function _write_gw_cpp(f, interface)
    if interface.name[1] == "I"
        gname = "PyG" + interface.name[2:end]
    else
        gname = "PyG" + interface.name
    end
    name = interface.name
    if interface.base == "IUnknown" || interface.base == "IDispatch"
        base_name = "PyGatewayBase"
    elseif interface.base[1] == "I"
        base_name = "PyG" + interface.base[2:end]
    else
        base_name = "PyG" + interface.base
    end
    write(
        f,
        "// ---------------------------------------------------\n//\n// Gateway Implementation\n" %
        Dict("name" => name, "gname" => gname, "base_name" => base_name),
    )
    for method in interface.methods
        write(f, "STDMETHODIMP %s::%s(\n" % (gname, method.name))
        if method.args
            for arg in method.args[begin:-1]
                inoutstr = join(arg.inout, "][")
                write(f, "\t\t/* [%s] */ %s,\n" % (inoutstr, GetRawDeclaration(arg)))
            end
            arg = method.args[end]
            inoutstr = join(arg.inout, "][")
            write(f, "\t\t/* [%s] */ %s)\n" % (inoutstr, GetRawDeclaration(arg)))
        else
            write(f, "\t\tvoid)\n")
        end
        write(f, "{\n\tPY_GATEWAY_METHOD;\n")
        cout = 0
        codePre = ""
        codePost = ""
        codeVars = ""
        argStr = ""
        needConversion = 0
        formatChars = ""
        if method.args
            for arg in method.args
                if HasAttribute(arg, "out")
                    cout = cout + 1
                    if arg.indirectionLevel == 2
                        write(f, "\tif (%s==NULL) return E_POINTER;\n" % arg.name)
                    end
                end
                if HasAttribute(arg, "in")
                    try
                        argCvt = makegwparse.make_arg_converter(arg)
                        SetGatewayMode(argCvt)
                        formatchar = GetFormatChar(argCvt)
                        needConversion = needConversion || NeedUSES_CONVERSION(argCvt)
                        if formatchar
                            formatChars = formatChars + formatchar
                            codeVars = codeVars + DeclareParseArgTupleInputConverter(argCvt)
                            argStr = argStr * ", " + GetBuildValueArg(argCvt)
                        end
                        codePre = codePre + GetBuildForGatewayPreCode(argCvt)
                        codePost = codePost + GetBuildForGatewayPostCode(argCvt)
                    catch exn
                        let why = exn
                            if why isa makegwparse.error_not_supported
                                write(
                                    f,
                                    "// *** The input argument %s of type \"%s\" was not processed ***\n//   - Please ensure this conversion function exists, and is appropriate\n//   - %s\n" %
                                    (arg.name, arg.raw_type, why),
                                )
                                write(
                                    f,
                                    "\tPyObject *ob%s = PyObject_From%s(%s);\n" %
                                    (arg.name, arg.type, arg.name),
                                )
                                write(
                                    f,
                                    "\tif (ob%s==NULL) return MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"%s\");\n" %
                                    (arg.name, method.name),
                                )
                                codePost = codePost + ("\tPy_DECREF(ob%s);\n" % arg.name)
                                formatChars = formatChars * "O"
                                argStr = argStr * (", ob%s" % arg.name)
                            end
                        end
                    end
                end
            end
        end
        if needConversion != 0
            write(f, "\tUSES_CONVERSION;\n")
        end
        write(f, codeVars)
        write(f, codePre)
        if cout != 0
            write(f, "\tPyObject *result;\n")
            resStr = "&result"
        else
            resStr = "NULL"
        end
        if formatChars
            fullArgStr = "%s, \"%s\"%s" % (resStr, formatChars, argStr)
        else
            fullArgStr = resStr
        end
        write(f, "\tHRESULT hr=InvokeViaPolicy(\"%s\", %s);\n" % (method.name, fullArgStr))
        write(f, codePost)
        if cout != 0
            write(f, "\tif (FAILED(hr)) return hr;\n")
            write(
                f,
                "\t// Process the Python results, and convert back to the real params\n",
            )
            formatChars = ""
            codePobjects = ""
            codePost = ""
            argsParseTuple = ""
            needConversion = 0
            for arg in method.args
                if !HasAttribute(arg, "out")
                    continue
                end
                try
                    argCvt = makegwparse.make_arg_converter(arg)
                    SetGatewayMode(argCvt)
                    val = GetFormatChar(argCvt)
                    if val
                        formatChars = formatChars + val
                        argsParseTuple = argsParseTuple * ", " + GetParseTupleArg(argCvt)
                        codePobjects =
                            codePobjects + DeclareParseArgTupleInputConverter(argCvt)
                        codePost = codePost + GetParsePostCode(argCvt)
                        needConversion = needConversion || NeedUSES_CONVERSION(argCvt)
                    end
                catch exn
                    let why = exn
                        if why isa makegwparse.error_not_supported
                            write(
                                f,
                                "// *** The output argument %s of type \"%s\" was not processed ***\n//     %s\n" %
                                (arg.name, arg.raw_type, why),
                            )
                        end
                    end
                end
            end
            if formatChars
                if length(formatChars) == 1
                    parseFn = "PyArg_Parse"
                else
                    parseFn = "PyArg_ParseTuple"
                end
                if codePobjects
                    write(f, codePobjects)
                end
                write(
                    f,
                    "\tif (!%s(result, \"%s\" %s))\n\t\treturn MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"%s\");\n" %
                    (parseFn, formatChars, argsParseTuple, method.name),
                )
            end
            if codePost
                write(f, "\tBOOL bPythonIsHappy = TRUE;\n")
                write(f, codePost)
                write(
                    f,
                    "\tif (!bPythonIsHappy) hr = MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"%s\");\n" %
                    method.name,
                )
            end
            write(f, "\tPy_DECREF(result);\n")
        end
        write(f, "\treturn hr;\n}\n\n")
    end
end

function test()
    make_framework_support("d:\\msdev\\include\\objidl.h", "IStorage")
end
