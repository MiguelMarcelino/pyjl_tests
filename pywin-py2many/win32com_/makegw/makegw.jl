#= Utility functions for writing out gateway C++ files

  This module will generate a C++/Python binding for a specific COM
  interface.
  
  At this stage, no command line interface exists.  You must start Python, 
  import this module,  change to the directory where the generated code should
  be written, and run the public function.
  
  This module is capable of generating both 'Interfaces' (ie, Python
  client side support for the interface) and 'Gateways' (ie, Python
  server side support for the interface).  Many COM interfaces are useful
  both as Client and Server.  Other interfaces, however, really only make
  sense to implement one side or the other.  For example, it would be pointless
  for Python to implement Server side for 'IRunningObjectTable', unless we were
  implementing core COM for an operating system in Python (hey - now there's an idea!)
  
  Most COM interface code is totally boiler-plate - it consists of
  converting arguments, dispatching the call to Python, and processing
  any result values.
  
  This module automates the generation of such code.  It has the ability to
  parse a .H file generated by the MIDL tool (ie, almost all COM .h files)
  and build almost totally complete C++ code.
  
  The module understands some of the well known data types, and how to
  convert them.  There are only a couple of places where hand-editing is
  necessary, as detailed below:

  unsupported types -- If a type is not known, the generator will
  pretty much ignore it, but write a comment to the generated code.  You
  may want to add custom support for this type.  In some cases, C++ compile errors
  will result.  These are intentional - generating code to remove these errors would
  imply a false sense of security that the generator has done the right thing.

  other return policies -- By default, Python never sees the return SCODE from
  a COM function.  The interface usually returns None if OK, else a COM exception
  if "FAILED(scode)" is TRUE.  You may need to change this if:
  * EXCEPINFO is passed to the COM function.  This is not detected and handled
  * For some reason Python should always see the result SCODE, even if it
    did fail or succeed.  For example, some functions return a BOOLEAN result
    in the SCODE, meaning Python should always see it.
  * FAILED(scode) for the interface still has valid data to return (by default,
    the code generated does not process the return values, and raise an exception
    to Python/COM
  
 =#
import win32com_.makegw.makegwenum

include("makegwparse.jl")
function make_framework_support(header_file_name, interface_name, bMakeInterface = 1, bMakeGateway = 1)
#= Generate C++ code for a Python Interface and Gateway

    header_file_name -- The full path to the .H file which defines the interface.
    interface_name -- The name of the interface to search for, and to generate.
    bMakeInterface = 1 -- Should interface (ie, client) support be generated.
    bMakeGatewayInterface = 1 -- Should gateway (ie, server) support be generated.

    This method will write a .cpp and .h file into the current directory,
    (using the name of the interface to build the file name.

     =#
fin = readline(header_file_name)
try
interface = makegwparse.parse_interface_info(interface_name, fin)
finally
close(fin)
end
if bMakeInterface && bMakeGateway
desc = "Interface and Gateway"
elseif bMakeInterface && !(bMakeGateway)
desc = "Interface"
else
desc = "Gateway"
end
if interface.name[begin:5] == "IEnum"
ifc_cpp_writer = win32com_.makegw.makegwenum._write_enumifc_cpp
gw_cpp_writer = win32com_.makegw.makegwenum._write_enumgw_cpp
else
ifc_cpp_writer = _write_ifc_cpp
gw_cpp_writer = _write_gw_cpp
end
fout = readline("Py.cpp")
try
write(fout, "$(interface.name)$(desc) for Python.
// Generated by makegw.py

#include "shell_pch.h"
")
write(fout, "#include "Py.h"

// @doc - This file contains autoduck documentation
")
if bMakeInterface
ifc_cpp_writer(fout, interface)
end
if bMakeGateway
gw_cpp_writer(fout, interface)
end
finally
close(fout)
end
fout = readline("Py.h")
try
write(fout, "$(interface.name)$(desc) for Python.
// Generated by makegw.py
")
if bMakeInterface
_write_ifc_h(fout, interface)
end
if bMakeGateway
_write_gw_h(fout, interface)
end
finally
close(fout)
end
end

function _write_ifc_h(f, interface)
write(f, "$(interface.name)$(interface.base)$(interface.name)$(interface.name) *GetI(PyObject *self);
	static PyComTypeObject type;

	// The Python methods
")
for method in interface.methods
write(f, "	static PyObject *(PyObject *self, PyObject *args);
")
end
write(f, "$(interface.name)$(interface.name)();
};
")
end

function _write_ifc_cpp(f, interface)
name = interface.name
write(f, "// ---------------------------------------------------
//
// Interface Implementation

Pyname)s::Pyname)s(IUnknown *pdisp):
	Pybase)s(pdisp)
{
	ob_type = &type;
}

Pyname)s::~Pyname)s()
{
}

/* static */ name)s *Pyname)s::GetI(PyObject *self)
{
	return (name)s *)Pybase)s::GetI(self);
}

")
ptr = 
                # Unsupported use of re.sub with less than 3 arguments
                sub()("[a-z]", "", interface.name)
strdict = Dict("interfacename" => interface.name, "ptr" => ptr)
for method in interface.methods
strdict["method"] = method.name
write(f, "// @pymethod |Pyinterfacename)s|method)s|Description of method)s.
PyObject *Pyinterfacename)s::method)s(PyObject *self, PyObject *args)
{
	interfacename)s *pptr)s = GetI(self);
	if ( pptr)s == NULL )
		return NULL;
")
argsParseTuple = ""
argsCOM = ""
formatChars = ""
codePost = ""
codePobjects = ""
codeCobjects = ""
cleanup = ""
cleanup_gil = ""
needConversion = 0
for arg in method.args
try
argCvt = makegwparse.make_arg_converter(arg)
if HasAttribute(arg, "in")
val = GetFormatChar(argCvt)
if val
write(f, ("\t" + GetAutoduckString(argCvt)) * "\n")
formatChars = formatChars + val
argsParseTuple = argsParseTuple * ", " + GetParseTupleArg(argCvt)
codePobjects = codePobjects + DeclareParseArgTupleInputConverter(argCvt)
codePost = codePost + GetParsePostCode(argCvt)
needConversion = needConversion || NeedUSES_CONVERSION(argCvt)
cleanup = cleanup + GetInterfaceArgCleanup(argCvt)
cleanup_gil = cleanup_gil + GetInterfaceArgCleanupGIL(argCvt)
end
end
comArgName, comArgDeclString = GetInterfaceCppObjectInfo(argCvt)
if comArgDeclString
codeCobjects = codeCobjects * "	;
"
end
argsCOM = argsCOM * ", " + comArgName
catch exn
 let why = exn
if why isa makegwparse.error_not_supported
write(f, "$(arg.name)$(arg.raw_type)" was not processed ***
//     Please check the conversion function is appropriate and exists!
")
write(f, "$(arg.type)$(arg.name)$(arg.name);
")
write(f, "$(arg.type)$(arg.name)$(arg.name)
")
codePost = codePost + "$(arg.type)$(arg.name)$(arg.name) )) bPythonIsHappy = FALSE;
"
formatChars = formatChars * "O"
argsParseTuple = argsParseTuple * ", &ob"
argsCOM = argsCOM * ", " + arg.name
cleanup = cleanup + "$(arg.type)$(arg.name));
"
end
end
end
end
if needConversion != 0
write(f, "\tUSES_CONVERSION;\n")
end
write(f, codePobjects)
write(f, codeCobjects)
write(f, "$(formatChars)$(method.name)$(argsParseTuple)) )
		return NULL;
")
if codePost
write(f, "\tBOOL bPythonIsHappy = TRUE;\n")
write(f, codePost)
write(f, "\tif (!bPythonIsHappy) return NULL;\n")
end
strdict["argsCOM"] = argsCOM[2:end]
strdict["cleanup"] = cleanup
strdict["cleanup_gil"] = cleanup_gil
write(f, "	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pptr)s->method)s(argsCOM)s );
cleanup)s
	PY_INTERFACE_POSTCALL;
cleanup_gil)s
	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pptr)s, IID_interfacename)s );
")
codePre = ""
codePost = ""
formatChars = ""
codeVarsPass = ""
codeDecl = ""
for arg in method.args
if !HasAttribute(arg, "out")
continue;
end
try
argCvt = makegwparse.make_arg_converter(arg)
formatChar = GetFormatChar(argCvt)
if formatChar
formatChars = formatChars + formatChar
codePre = codePre + GetBuildForInterfacePreCode(argCvt)
codePost = codePost + GetBuildForInterfacePostCode(argCvt)
codeVarsPass = codeVarsPass * ", " + GetBuildValueArg(argCvt)
codeDecl = codeDecl + DeclareParseArgTupleInputConverter(argCvt)
end
catch exn
 let why = exn
if why isa makegwparse.error_not_supported
write(f, "$(arg.name)$(arg.raw_type)$(why)
")
continue;
end
end
end
end
if formatChars
write(f, "$(codeDecl)$(codePre)$(formatChars)$(codeVarsPass)$(codePost)	return pyretval;")
else
write(f, "\tPy_INCREF(Py_None);\n\treturn Py_None;\n")
end
write(f, "\n}\n\n")
end
write(f, "// @object Py|Description of the interface
")
write(f, "static struct PyMethodDef Py_methods[] =
{
")
for method in interface.methods
write(f, "$(method.name)$(interface.name)$(method.name)$(method.name)$(method.name)
")
end
interfacebase = interface.base
write(f, "	{ NULL }
};

PyComTypeObject Pyname)s::type("Pyname)s",
		&Pyinterfacebase)s::type,
		sizeof(Pyname)s),
		Pyname)s_methods,
		GET_PYCOM_CTOR(Pyname)s));
")
end

function _write_gw_h(f, interface)
if interface.name[1] == "I"
gname = "PyG" + interface.name[2:end]
else
gname = "PyG" + interface.name
end
name = interface.name
if interface.base == "IUnknown" || interface.base == "IDispatch"
base_name = "PyGatewayBase"
elseif interface.base[1] == "I"
base_name = "PyG" + interface.base[2:end]
else
base_name = "PyG" + interface.base
end
write(f, "$(gname)$(base_name)$(name)$(gname)$(base_name)$(gname)$(name)$(name)$(base_name))

")
if interface.base != "IUnknown"
write(f, "$(interface.base)$(interface.base) method decls here

")
else
write(f, "\n\n")
end
write(f, "	// 
")
for method in interface.methods
write(f, "	STDMETHOD()(
")
if method.args
for arg in method.args[begin:-1]
write(f, "		,
")
end
arg = method.args[end]
write(f, "		);

")
else
write(f, "\t\tvoid);\n\n")
end
end
write(f, "};\n")
close(f)
end

function _write_gw_cpp(f, interface)
if interface.name[1] == "I"
gname = "PyG" + interface.name[2:end]
else
gname = "PyG" + interface.name
end
name = interface.name
if interface.base == "IUnknown" || interface.base == "IDispatch"
base_name = "PyGatewayBase"
elseif interface.base[1] == "I"
base_name = "PyG" + interface.base[2:end]
else
base_name = "PyG" + interface.base
end
write(f, "// ---------------------------------------------------\n//\n// Gateway Implementation\n" % Dict("name" => name, "gname" => gname, "base_name" => base_name))
for method in interface.methods
write(f, "$(gname)$(method.name)(
")
if method.args
for arg in method.args[begin:-1]
inoutstr = join(arg.inout, "][")
write(f, "$(inoutstr)$(GetRawDeclaration(arg)),
")
end
arg = method.args[end]
inoutstr = join(arg.inout, "][")
write(f, "$(inoutstr)$(GetRawDeclaration(arg)))
")
else
write(f, "\t\tvoid)\n")
end
write(f, "{\n\tPY_GATEWAY_METHOD;\n")
cout = 0
codePre = ""
codePost = ""
codeVars = ""
argStr = ""
needConversion = 0
formatChars = ""
if method.args
for arg in method.args
if HasAttribute(arg, "out")
cout = cout + 1
if arg.indirectionLevel == 2
write(f, "	if (==NULL) return E_POINTER;
")
end
end
if HasAttribute(arg, "in")
try
argCvt = makegwparse.make_arg_converter(arg)
SetGatewayMode(argCvt)
formatchar = GetFormatChar(argCvt)
needConversion = needConversion || NeedUSES_CONVERSION(argCvt)
if formatchar
formatChars = formatChars + formatchar
codeVars = codeVars + DeclareParseArgTupleInputConverter(argCvt)
argStr = argStr * ", " + GetBuildValueArg(argCvt)
end
codePre = codePre + GetBuildForGatewayPreCode(argCvt)
codePost = codePost + GetBuildForGatewayPostCode(argCvt)
catch exn
 let why = exn
if why isa makegwparse.error_not_supported
write(f, "$(arg.name)$(arg.raw_type)$(why)
")
write(f, "$(arg.name)$(arg.type)$(arg.name));
")
write(f, "$(arg.name)$(method.name)");
")
codePost = codePost + "	Py_DECREF(ob);
"
formatChars = formatChars * "O"
argStr = argStr * ", ob"
end
end
end
end
end
end
if needConversion != 0
write(f, "\tUSES_CONVERSION;\n")
end
write(f, codeVars)
write(f, codePre)
if cout != 0
write(f, "\tPyObject *result;\n")
resStr = "&result"
else
resStr = "NULL"
end
if formatChars
fullArgStr = "$(resStr)$(formatChars)$(argStr)"
else
fullArgStr = resStr
end
write(f, "$(method.name)$(fullArgStr));
")
write(f, codePost)
if cout != 0
write(f, "\tif (FAILED(hr)) return hr;\n")
write(f, "\t// Process the Python results, and convert back to the real params\n")
formatChars = ""
codePobjects = ""
codePost = ""
argsParseTuple = ""
needConversion = 0
for arg in method.args
if !HasAttribute(arg, "out")
continue;
end
try
argCvt = makegwparse.make_arg_converter(arg)
SetGatewayMode(argCvt)
val = GetFormatChar(argCvt)
if val
formatChars = formatChars + val
argsParseTuple = argsParseTuple * ", " + GetParseTupleArg(argCvt)
codePobjects = codePobjects + DeclareParseArgTupleInputConverter(argCvt)
codePost = codePost + GetParsePostCode(argCvt)
needConversion = needConversion || NeedUSES_CONVERSION(argCvt)
end
catch exn
 let why = exn
if why isa makegwparse.error_not_supported
write(f, "$(arg.name)$(arg.raw_type)$(why)
")
end
end
end
end
if formatChars
if length(formatChars) == 1
parseFn = "PyArg_Parse"
else
parseFn = "PyArg_ParseTuple"
end
if codePobjects
write(f, codePobjects)
end
write(f, "$(parseFn)$(formatChars)$(argsParseTuple)$(method.name)");
")
end
if codePost
write(f, "\tBOOL bPythonIsHappy = TRUE;\n")
write(f, codePost)
write(f, "	if (!bPythonIsHappy) hr = MAKE_PYCOM_GATEWAY_FAILURE_CODE("");
")
end
write(f, "\tPy_DECREF(result);\n")
end
write(f, "\treturn hr;\n}\n\n")
end
end

function test()
make_framework_support("d:\\msdev\\include\\objidl.h", "IStorage")
end
